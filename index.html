<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Binance USDT Perps Dashboard</title>
  <style>
    :root{ --bg:#0b0f14; --card:#121821; --muted:#6b7a90; --text:#e8eef6; --accent:#4cc9f0; --pos:#22c55e; --neg:#ef4444; }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Inter,Arial;background:var(--bg);color:var(--text)}
    header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg, rgba(11,15,20,0.95), rgba(11,15,20,0.85) 60%, rgba(11,15,20,0));backdrop-filter:saturate(1.2) blur(6px);}  
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    h1{font-size:20px;margin:0 0 8px;display:flex;align-items:center;gap:10px}
    h1 span.badge{font-size:12px;background:var(--card);color:var(--muted);border:1px solid #1f2a38;padding:2px 8px;border-radius:999px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    input[type="search"]{flex:1 1 220px;background:#0e141c;color:var(--text);border:1px solid #203045;border-radius:10px;padding:10px 12px;outline:none}
    button{background:var(--accent);color:#04131b;border:0;border-radius:10px;padding:10px 12px;font-weight:600;cursor:pointer}
    button.secondary{background:#203045;color:var(--text)}
    .hint{font-size:12px;color:var(--muted)}
    .card{background:var(--card);border:1px solid #1f2a38;border-radius:16px;overflow:hidden}
    table{width:100%;border-collapse:separate;border-spacing:0}
    thead th{position:sticky;top:0;background:#0f1620;border-bottom:1px solid #1f2a38;padding:12px;font-size:12px;text-align:left;color:#a9b6c8;letter-spacing:.02em;cursor:pointer}
    tbody td{border-bottom:1px solid #17202d;padding:12px;font-size:14px}
    tbody tr:hover{background:#0f1620}
    .mono{font-variant-numeric:tabular-nums}
    .pos{color:var(--pos)}
    .neg{color:var(--neg)}
    .skeleton{display:inline-block;min-width:48px;height:1em;background:linear-gradient(90deg,#1a2331,#263449,#1a2331);border-radius:4px;animation:shimmer 1.4s infinite}
    @keyframes shimmer{0%{background-position:-100px 0}100%{background-position:100px 0}}
    .footer{color:var(--muted);font-size:12px;padding:12px 16px}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>
        Binance USDT-M Perpetuals Dashboard
        <span class="badge" id="lastUpdated">—</span>
      </h1>
      <div class="controls">
        <input id="search" type="search" placeholder="Filter by symbol (e.g., BTC, ETH, RNDR)…" />
        <button id="refresh">Refresh now</button>
        <button id="toggleTop" class="secondary">Show: Top 50 by volume</button>
        <span class="hint">Columns: Pair · Price · Funding · Funding Interval · Daily % · Effective APR · Last 7d APR · Last 14d APR · 24h Volume · Spot 24h Volume (if available)</span>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div class="card">
      <table id="table">
        <thead>
          <tr>
            <th data-key="symbol">Pair ▲▼</th>
            <th data-key="lastPrice">Price (USDT)</th>
            <th data-key="fundingRate">Funding Rate</th>
            <th data-key="fundingIntervalHrs">Funding Interval (hrs)</th>
            <th data-key="dailyPct">Daily %</th>
            <th data-key="aprNow">Effective APR (now)</th>
            <th data-key="apr7d">Last 7 days APR</th>
            <th data-key="apr14d">Last 14 days APR</th>
            <th data-key="quoteVolume">24h Volume (USDT)</th>
            <th data-key="spotVolume">Spot 24h Volume (USDT)</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
      <div class="footer">Data: Binance Futures & Spot public APIs. Funding interval inferred from /fapi/v1/fundingRate spacing (default 8h unless otherwise specified). This is a client‑side demo; no API keys or backend needed.</div>
    </div>
  </main>

  <script>
    // ====== Config ======
    const API = {
      exchangeInfo: 'https://fapi.binance.com/fapi/v1/exchangeInfo',
      premiumIndex:  'https://fapi.binance.com/fapi/v1/premiumIndex',
      ticker24hr:    'https://fapi.binance.com/fapi/v1/ticker/24hr',
      fundingHistory: 'https://fapi.binance.com/fapi/v1/fundingRate',
      spotTicker24hr: 'https://api.binance.com/api/v3/ticker/24hr'
    };
    const MAX_7D_SYMBOLS = 50; // used for 14d too; one fetch computes both
    const CONCURRENCY = 5;
    const DEFAULT_FUNDING_INTERVAL_HRS = 8;

    // ====== Utils ======
    const nf0 = new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 });
    const nf2 = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const pf2 = new Intl.NumberFormat(undefined, { style: 'percent', minimumFractionDigits: 2, maximumFractionDigits: 2 });

    function toPercent(n){ return pf2.format(n); }
    function toAPRFromPeriodRate(r, intervalHrs){
      const periodsPerDay = 24/intervalHrs;
      const periods = periodsPerDay * 365;
      return Math.pow(1 + r, periods) - 1;
    }
    function toAPRFromSeries(series, intervalHrs){
      if(!series.length) return null;
      const product = series.reduce((acc, r) => acc * (1 + parseFloat(r)), 1);
      const perPeriodGeoMean = Math.pow(product, 1/series.length) - 1;
      return toAPRFromPeriodRate(perPeriodGeoMean, intervalHrs);
    }
    function classForSigned(n){ return n >= 0 ? 'pos' : 'neg'; }
    function nowString(){ return new Date().toLocaleString(); }
    function calcDailyPct(r, intervalHrs){
      if(!Number.isFinite(r) || !intervalHrs) return null;
      return (24/intervalHrs) * r;
    }

    // ====== Data Fetch ======
    async function fetchAll(){
      const [exInfo, prem, t24, spot24] = await Promise.all([
        fetch(API.exchangeInfo).then(r=>r.json()),
        fetch(API.premiumIndex).then(r=>r.json()),
        fetch(API.ticker24hr).then(r=>r.json()),
        fetch(API.spotTicker24hr).then(r=>r.json())
      ]);

      const allowed = new Set(
        exInfo.symbols
          .filter(s => s.contractType === 'PERPETUAL' && s.quoteAsset === 'USDT' && s.status === 'TRADING')
          .map(s => s.symbol)
      );

      const bySymbol = arr => Object.fromEntries(arr.map(o => [o.symbol, o]));
      const premBy = bySymbol(prem.filter(p => allowed.has(p.symbol)));
      const t24By = bySymbol(t24.filter(t => allowed.has(t.symbol)));
      const spotBy = bySymbol(Array.isArray(spot24) ? spot24 : []);

      let rows = Array.from(allowed).map(sym => {
        const p = premBy[sym];
        const t = t24By[sym];
        const r = p ? parseFloat(p.lastFundingRate) : NaN; // decimal
        const quoteVol = t ? parseFloat(t.quoteVolume) : 0;
        const lastPrice = t ? parseFloat(t.lastPrice) : null;
        const interval = DEFAULT_FUNDING_INTERVAL_HRS;
        const base = sym.replace(/USDT$/, '');
        const spotSym = base + 'USDT';
        const spotVol = spotBy[spotSym] ? parseFloat(spotBy[spotSym].quoteVolume) : null;

        return {
          symbol: sym,
          lastPrice,
          fundingRate: r,
          fundingIntervalHrs: interval,
          dailyPct: Number.isFinite(r) ? calcDailyPct(r, interval) : null,
          aprNow: Number.isFinite(r) ? toAPRFromPeriodRate(r, interval) : null,
          apr7d: null,
          apr14d: null,
          quoteVolume: quoteVol,
          spotVolume: spotVol,
        };
      });

      rows.sort((a,b)=>b.quoteVolume - a.quoteVolume);
      return rows;
    }

    // Fetch once per symbol and compute 7d & 14d APRs
    async function computeAPRsCombined(symbol, intervalHrs){
      const needed14 = Math.max(1, Math.ceil(14 * 24 / intervalHrs));
      const limit = Math.min(needed14 + 2, 200); // small buffer, capped
      const url = new URL(API.fundingHistory);
      url.searchParams.set('symbol', symbol);
      url.searchParams.set('limit', String(limit));
      const data = await fetch(url).then(r=>r.json());
      const series = (Array.isArray(data) ? data : [])
        .map(x => parseFloat(x.fundingRate))
        .filter(n => Number.isFinite(n));
      const needed7 = Math.max(1, Math.ceil(7 * 24 / intervalHrs));
      const last7  = series.slice(-needed7);
      const last14 = series.slice(-needed14);
      return { apr7d: toAPRFromSeries(last7, intervalHrs), apr14d: toAPRFromSeries(last14, intervalHrs) };
    }

    async function fillHistoricalAPRs(rows){
      const top = rows.slice(0, MAX_7D_SYMBOLS);
      let i = 0;
      async function worker(){
        while(i < top.length){
          const idx = i++;
          const sym = top[idx].symbol;
          try{ 
            const both = await computeAPRsCombined(sym, rows[idx].fundingIntervalHrs);
            rows[idx].apr7d = both.apr7d;
            rows[idx].apr14d = both.apr14d;
          } catch(e){ rows[idx].apr7d = null; rows[idx].apr14d = null; }
          renderRow(rows[idx]);
        }
      }
      await Promise.all(Array.from({length:CONCURRENCY}, worker));
    }

    // Infer funding interval by inspecting spacing of fundingTime entries
    async function inferIntervalFromFundingHistory(symbol){
      const url = new URL(API.fundingHistory);
      url.searchParams.set('symbol', symbol);
      url.searchParams.set('limit', '25');
      const data = await fetch(url).then(r=>r.json());
      const arr = Array.isArray(data) ? data : [];
      if(arr.length < 3) return null;
      arr.sort((a,b)=>a.fundingTime - b.fundingTime);
      const H = 3600000; // ms per hour
      const deltas = [];
      for(let i=1;i<arr.length;i++){
        const dt = Math.abs(arr[i].fundingTime - arr[i-1].fundingTime);
        const hrs = dt / H;
        if(hrs > 0.5 && hrs <= 24) deltas.push(hrs);
      }
      if(!deltas.length) return null;
      deltas.sort((a,b)=>a-b);
      const mid = Math.floor(deltas.length/2);
      const median = deltas.length % 2 ? deltas[mid] : (deltas[mid-1] + deltas[mid]) / 2;
      return Math.round(median);
    }

    async function fillFundingIntervalsFromHistory(rows){
      let i = 0;
      async function worker(){
        while(i < rows.length){
          const idx = i++;
          const sym = rows[idx].symbol;
          try{
            const inferred = await inferIntervalFromFundingHistory(sym);
            if(inferred && inferred !== rows[idx].fundingIntervalHrs){
              rows[idx].fundingIntervalHrs = inferred;
              if(Number.isFinite(rows[idx].fundingRate)){
                rows[idx].dailyPct = calcDailyPct(rows[idx].fundingRate, inferred);
                rows[idx].aprNow = toAPRFromPeriodRate(rows[idx].fundingRate, inferred);
              }
              try{
                const both = await computeAPRsCombined(sym, inferred);
                rows[idx].apr7d = both.apr7d;
                rows[idx].apr14d = both.apr14d;
              }catch(_){ }
              renderRow(rows[idx]);
            }
          }catch(e){ /* ignore per-symbol errors */ }
        }
      }
      await Promise.all(Array.from({length:CONCURRENCY}, worker));
    }

    // ====== UI Rendering ======
    const tbody = document.getElementById('tbody');
    let currentRows = [];
    let sortKey = 'quoteVolume';
    let sortDir = 'desc';
    let showTopOnly = true;

    function renderAll(){
      tbody.innerHTML = '';
      const filtered = filterRows(currentRows);
      filtered.forEach(renderRow);
    }

    function renderRow(row){
      let tr = document.querySelector(`tr[data-sym="${row.symbol}"]`);
      if(!tr){
        tr = document.createElement('tr');
        tr.dataset.sym = row.symbol;
        tr.innerHTML = `
          <td class="mono"></td>
          <td class="mono"></td>
          <td class="mono"></td>
          <td class="mono"></td>
          <td class="mono"></td>
          <td class="mono"></td>
          <td class="mono"></td>
          <td class="mono"></td>
          <td class="mono"></td>
          <td class="mono"></td>
        `;
        tbody.appendChild(tr);
      }
      const cells = tr.children;
      cells[0].textContent = row.symbol;
      cells[1].textContent = row.lastPrice ? nf2.format(row.lastPrice) : '—';
      if(Number.isFinite(row.fundingRate)){
        cells[2].innerHTML = `<span class="${classForSigned(row.fundingRate)}">${toPercent(row.fundingRate)}</span>`;
      } else {
        cells[2].innerHTML = '<span class="skeleton"></span>';
      }
      cells[3].textContent = nf0.format(row.fundingIntervalHrs);
      cells[4].innerHTML = row.dailyPct==null ? '<span class="skeleton"></span>' : `<span class="${classForSigned(row.dailyPct)}">${toPercent(row.dailyPct)}</span>`;
      cells[5].innerHTML = row.aprNow==null ? '<span class="skeleton"></span>' : `<span class="${classForSigned(row.aprNow)}">${toPercent(row.aprNow)}</span>`;
      cells[6].innerHTML = row.apr7d==null ? '<span class="skeleton"></span>' : `<span class="${classForSigned(row.apr7d)}">${toPercent(row.apr7d)}</span>`;
      cells[7].innerHTML = row.apr14d==null ? '<span class="skeleton"></span>' : `<span class="${classForSigned(row.apr14d)}">${toPercent(row.apr14d)}</span>`;
      cells[8].textContent = row.quoteVolume ? nf0.format(row.quoteVolume) : '—';
      cells[9].textContent = Number.isFinite(row.spotVolume) ? nf0.format(row.spotVolume) : 'n/a';
    }

    function filterRows(rows){
      const q = document.getElementById('search').value.trim().toUpperCase();
      let list = rows;
      if(q) list = list.filter(r => r.symbol.includes(q));
      if(showTopOnly) list = list.slice(0, MAX_7D_SYMBOLS);
      list = list.slice().sort((a,b)=>{
        const dir = sortDir === 'asc' ? 1 : -1;
        if(sortKey === 'symbol') return a.symbol.localeCompare(b.symbol) * dir;
        const av = a[sortKey];
        const bv = b[sortKey];
        const aa = (av==null || !Number.isFinite(av)) ? -Infinity : av;
        const bb = (bv==null || !Number.isFinite(bv)) ? -Infinity : bv;
        if(aa < bb) return 1*dir;
        if(aa > bb) return -1*dir;
        return a.symbol.localeCompare(b.symbol);
      });
      return list;
    }

    // ====== Events ======
    document.getElementById('refresh').addEventListener('click', init);
    document.getElementById('search').addEventListener('input', renderAll);
    document.getElementById('toggleTop').addEventListener('click', () => {
      showTopOnly = !showTopOnly;
      document.getElementById('toggleTop').textContent = showTopOnly ? 'Show: Top 50 by volume' : 'Show: All';
      renderAll();
    });
    document.querySelectorAll('thead th').forEach(th => th.addEventListener('click', ()=>{
      const key = th.dataset.key;
      if(key){
        if(sortKey === key){ sortDir = sortDir === 'asc' ? 'desc' : 'asc'; }
        else { sortKey = key; sortDir = key==='symbol' ? 'asc' : 'desc'; }
        renderAll();
      }
    }));

    // ====== Init ======
    async function init(){
      document.getElementById('lastUpdated').textContent = 'Refreshing…';
      try{
        currentRows = await fetchAll();
        renderAll();
        document.getElementById('lastUpdated').textContent = 'Updated: ' + nowString();
        fillHistoricalAPRs(currentRows).catch(()=>{});
        fillFundingIntervalsFromHistory(currentRows).catch(()=>{});
      }catch(err){
        console.error(err);
        document.getElementById('lastUpdated').textContent = 'Error loading data';
        tbody.innerHTML = `<tr><td colspan="10" style="color:var(--muted);padding:16px;">Failed to load from Binance API. Try again.</td></tr>`;
      }
    }

    // Optional auto-refresh every 2 minutes
    setInterval(init, 2*60*1000);

    init();
  </script>
</body>
</html>
