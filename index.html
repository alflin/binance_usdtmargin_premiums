<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Perps Dashboard — Binance & OKX</title>
  <style>
    :root{ --bg:#0b0f14; --card:#121821; --muted:#6b7a90; --text:#e8eef6; --accent:#4cc9f0; --pos:#22c55e; --neg:#ef4444; }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Inter,Arial;background:var(--bg);color:var(--text)}
    header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg, rgba(11,15,20,0.95), rgba(11,15,20,0.85) 60%, rgba(11,15,20,0));backdrop-filter:saturate(1.2) blur(6px);}  
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    h1{font-size:20px;margin:0 0 8px;display:flex;align-items:center;gap:10px}
    h1 span.badge{font-size:12px;background:var(--card);color:var(--muted);border:1px solid #1f2a38;padding:2px 8px;border-radius:999px}
    .tabs{display:flex;gap:8px;margin:8px 0}
    .tab{padding:8px 16px;border-radius:8px;cursor:pointer;background:#203045;color:var(--text);user-select:none}
    .tab.active{background:var(--accent);color:#04131b;font-weight:600}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:8px}
    input[type="search"]{flex:1 1 220px;background:#0e141c;color:var(--text);border:1px solid #203045;border-radius:10px;padding:10px 12px;outline:none}
    button{background:var(--accent);color:#04131b;border:0;border-radius:10px;padding:10px 12px;font-weight:600;cursor:pointer}
    button.secondary{background:#203045;color:var(--text)}
    .hint{font-size:12px;color:var(--muted)}
    .card{background:var(--card);border:1px solid #1f2a38;border-radius:16px;overflow:hidden;margin-top:16px}
    table{width:100%;border-collapse:separate;border-spacing:0}
    thead th{position:sticky;top:0;background:#0f1620;border-bottom:1px solid #1f2a38;padding:12px;font-size:12px;text-align:left;color:#a9b6c8;letter-spacing:.02em;cursor:pointer}
    tbody td{border-bottom:1px solid #17202d;padding:12px;font-size:14px}
    tbody tr:hover{background:#0f1620}
    .mono{font-variant-numeric:tabular-nums}
    .pos{color:var(--pos)}
    .neg{color:var(--neg)}
    .skeleton{display:inline-block;min-width:48px;height:1em;background:linear-gradient(90deg,#1a2331,#263449,#1a2331);border-radius:4px;animation:shimmer 1.4s infinite}
    @keyframes shimmer{0%{background-position:-100px 0}100%{background-position:100px 0}}
    .footer{color:var(--muted);font-size:12px;padding:12px 16px}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>
        Perpetuals Dashboard
        <span class="badge" id="lastUpdated">—</span>
      </h1>
      <div class="tabs" id="exchangeTabs">
        <div class="tab active" data-exchange="binance">Binance</div>
        <div class="tab" data-exchange="okx">OKX</div>
      </div>
      <div class="controls">
        <input id="search" type="search" placeholder="Filter by symbol (e.g., BTC, ETH, RNDR)…" />
        <button id="refresh">Refresh now</button>
        <button id="toggleTop" class="secondary">Show: Top 50 by volume</button>
        <span class="hint">Exchange: <span id="exchangeName">Binance</span> · Columns: Pair · Price · Funding · Funding Interval · Daily % · Effective APR · Last 7d APR · Last 14d APR · 24h Volume · Spot 24h Volume (if available)</span>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div class="card">
      <table id="table">
        <thead>
          <tr>
            <th data-key="symbol">Pair ▲▼</th>
            <th data-key="lastPrice">Price (USDT)</th>
            <th data-key="fundingRate">Funding Rate</th>
            <th data-key="fundingIntervalHrs">Funding Interval (hrs)</th>
            <th data-key="dailyPct">Daily %</th>
            <th data-key="aprNow">Effective APR (now)</th>
            <th data-key="apr7d">Last 7 days APR</th>
            <th data-key="apr14d">Last 14 days APR</th>
            <th data-key="quoteVolume">24h Volume (USDT)</th>
            <th data-key="spotVolume">Spot 24h Volume (USDT)</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
      <div class="footer">Data: Binance & OKX public APIs. Funding interval inferred from recent funding timestamps (default 8h unless otherwise specified). This is a client‑side demo; no API keys or backend needed.</div>
    </div>
  </main>

  <script>
    // ============ Utilities & UI helpers ============
    const nf0 = new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 });
    const nf2 = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const pf2 = new Intl.NumberFormat(undefined, { style: 'percent', minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const debounce = (fn, ms=200)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };

    function toPercent(n){ return pf2.format(n); }
    function classForSigned(n){ return n >= 0 ? 'pos' : 'neg'; }
    function nowString(){ return new Date().toLocaleString(); }
    function toAPRFromPeriodRate(r, intervalHrs){ const perDay = 24/intervalHrs; const periods = perDay*365; return Math.pow(1+r, periods) - 1; }
    function toAPRFromSeries(series, intervalHrs){ if(!series.length) return null; const prod = series.reduce((a,r)=>a*(1+parseFloat(r)),1); const per = Math.pow(prod, 1/series.length) - 1; return toAPRFromPeriodRate(per, intervalHrs); }
    function calcDailyPct(r, intervalHrs){ if(!Number.isFinite(r) || !intervalHrs) return null; return (24/intervalHrs) * r; }

    // ============ Exchange modules ============
    const BINANCE = {
      name: 'Binance',
      API: {
        exchangeInfo: 'https://fapi.binance.com/fapi/v1/exchangeInfo',
        premiumIndex:  'https://fapi.binance.com/fapi/v1/premiumIndex',
        ticker24hr:    'https://fapi.binance.com/fapi/v1/ticker/24hr',
        fundingHistory:'https://fapi.binance.com/fapi/v1/fundingRate',
        spotTicker24hr:'https://api.binance.com/api/v3/ticker/24hr'
      },
      async fetchAll(){
        const [exInfo, prem, t24, spot24] = await Promise.all([
          fetch(this.API.exchangeInfo).then(r=>r.json()),
          fetch(this.API.premiumIndex).then(r=>r.json()),
          fetch(this.API.ticker24hr).then(r=>r.json()),
          fetch(this.API.spotTicker24hr).then(r=>r.json())
        ]);
        const allowed = new Set(
          exInfo.symbols
            .filter(s => s.contractType==='PERPETUAL' && s.quoteAsset==='USDT' && s.status==='TRADING')
            .map(s => s.symbol)
        );
        const bySym = a => Object.fromEntries(a.map(o=>[o.symbol, o]));
        const premBy = bySym(prem.filter(p=>allowed.has(p.symbol)));
        const t24By  = bySym(t24.filter(t=>allowed.has(t.symbol)));
        const spotBy = bySym(Array.isArray(spot24)?spot24:[]);
        const rows = Array.from(allowed).map(sym=>{
          const p = premBy[sym];
          const t = t24By[sym];
          const r = p ? parseFloat(p.lastFundingRate) : NaN;
          const qv= t ? parseFloat(t.quoteVolume) : 0;
          const last = t ? parseFloat(t.lastPrice) : null;
          const interval = 8; // default; infer later
          const spotVol = spotBy[sym] ? parseFloat(spotBy[sym].quoteVolume) : null;
          return {
            symbol: sym,
            lastPrice: last,
            fundingRate: r,
            fundingIntervalHrs: interval,
            dailyPct: Number.isFinite(r) ? calcDailyPct(r, interval) : null,
            aprNow: Number.isFinite(r) ? toAPRFromPeriodRate(r, interval) : null,
            apr7d: null,
            apr14d: null,
            quoteVolume: qv,
            spotVolume: spotVol,
          };
        }).sort((a,b)=>b.quoteVolume-a.quoteVolume);
        return rows;
      },
      async computeAPRsCombined(symbol, intervalHrs){
        const need14 = Math.max(1, Math.ceil(14*24/intervalHrs));
        const limit  = Math.min(need14+2, 200);
        const url = new URL(this.API.fundingHistory);
        url.searchParams.set('symbol', symbol);
        url.searchParams.set('limit', String(limit));
        const data = await fetch(url).then(r=>r.json());
        const series = (Array.isArray(data)?data:[]).map(x=>parseFloat(x.fundingRate)).filter(Number.isFinite);
        const need7 = Math.max(1, Math.ceil(7*24/intervalHrs));
        return { apr7d: toAPRFromSeries(series.slice(-need7), intervalHrs), apr14d: toAPRFromSeries(series.slice(-need14), intervalHrs) };
      },
      async inferInterval(symbol){
        const url = new URL(this.API.fundingHistory);
        url.searchParams.set('symbol', symbol);
        url.searchParams.set('limit','25');
        const data = await fetch(url).then(r=>r.json());
        const arr = Array.isArray(data)?data:[]; if(arr.length<3) return null;
        arr.sort((a,b)=>a.fundingTime-b.fundingTime);
        const H=3600000, gaps=[];
        for(let i=1;i<arr.length;i++){ const hrs=Math.abs(arr[i].fundingTime-arr[i-1].fundingTime)/H; if(hrs>0.5&&hrs<=24) gaps.push(hrs); }
        if(!gaps.length) return null; gaps.sort((a,b)=>a-b); const m=Math.floor(gaps.length/2); const med=gaps.length%2?gaps[m]:(gaps[m-1]+gaps[m])/2; return Math.round(med);
      },
    };

    const OKX = {
      name: 'OKX',
      API: {
        instruments:   'https://www.okx.com/api/v5/public/instruments?instType=SWAP',
        swapTickers:   'https://www.okx.com/api/v5/market/tickers?instType=SWAP',
        spotTickers:   'https://www.okx.com/api/v5/market/tickers?instType=SPOT',
        fundingHistory:'https://www.okx.com/api/v5/public/funding-rate-history',
        fundingNow:    'https://www.okx.com/api/v5/public/funding-rate'
      },
      async fetchAll(){
        const [inst, swapT, spotT] = await Promise.all([
          fetch(this.API.instruments).then(r=>r.json()),
          fetch(this.API.swapTickers).then(r=>r.json()),
          fetch(this.API.spotTickers).then(r=>r.json()),
        ]);
        const live = (inst.data||[]).filter(i=>i.settleCcy==='USDT' && i.state==='live');
        const allowed = new Set(live.map(i=>i.instId)); // e.g., BTC-USDT-SWAP
        const byId = res => Object.fromEntries((res.data||[]).map(o=>[o.instId, o]));
        const tBy = byId(swapT); const spotBy = byId(spotT);
        const rows = Array.from(allowed).map(id=>{
          const t=tBy[id]; const last=t?parseFloat(t.last):null; const qv=t?parseFloat(t.volCcy24h||t.volCcy):0;
          const interval=8; // default; infer later
          const spotId=id.replace('-SWAP',''); const spotRec=spotBy[spotId]; const spotVol=spotRec?parseFloat(spotRec.volCcy24h||spotRec.volCcy):null;
          return {
            symbol: id.replace('-USDT-SWAP','USDT'),
            okxInstId: id,
            lastPrice: last,
            fundingRate: null,
            fundingIntervalHrs: interval,
            dailyPct: null,
            aprNow: null,
            apr7d: null,
            apr14d: null,
            quoteVolume: qv,
            spotVolume: spotVol,
          };
        }).sort((a,b)=>b.quoteVolume-a.quoteVolume);
        return rows;
      },
      async computeAPRsCombined(instId, intervalHrs){
        const need14 = Math.max(1, Math.ceil(14*24/intervalHrs));
        const limit  = Math.min(need14+2, 100);
        const url = new URL(this.API.fundingHistory);
        url.searchParams.set('instId', instId);
        url.searchParams.set('limit', String(limit));
        const data = await fetch(url).then(r=>r.json());
        const series = (data.data||[]).map(x=>parseFloat(x.fundingRate)).filter(Number.isFinite);
        const need7 = Math.max(1, Math.ceil(7*24/intervalHrs));
        return { apr7d: toAPRFromSeries(series.slice(-need7), intervalHrs), apr14d: toAPRFromSeries(series.slice(-need14), intervalHrs) };
      },
      async inferInterval(instId){
        const url = new URL(this.API.fundingHistory);
        url.searchParams.set('instId', instId);
        url.searchParams.set('limit','25');
        const data = await fetch(url).then(r=>r.json());
        const arr = data.data||[]; if(arr.length<3) return null;
        arr.sort((a,b)=>parseInt(a.fundingTime,10)-parseInt(b.fundingTime,10));
        const H=3600000, gaps=[];
        for(let i=1;i<arr.length;i++){ const hrs=Math.abs(parseInt(arr[i].fundingTime,10)-parseInt(arr[i-1].fundingTime,10))/H; if(hrs>0.5&&hrs<=24) gaps.push(hrs); }
        if(!gaps.length) return null; gaps.sort((a,b)=>a-b); const m=Math.floor(gaps.length/2); const med=gaps.length%2?gaps[m]:(gaps[m-1]+gaps[m])/2; return Math.round(med);
      },
      async fillFundingRatesNow(rows){
        let i=0; const CONC=6;
        async function worker(){
          while(i<rows.length){ const idx=i++; const r=rows[idx]; try{
            const url=new URL(OKX.API.fundingNow); url.searchParams.set('instId', r.okxInstId);
            const js=await fetch(url).then(x=>x.json()); const rec=(js.data||[])[0]; const fr=rec?parseFloat(rec.fundingRate):null;
            if(Number.isFinite(fr)){ r.fundingRate=fr; r.dailyPct=calcDailyPct(fr, r.fundingIntervalHrs); r.aprNow=toAPRFromPeriodRate(fr, r.fundingIntervalHrs); renderRow(r); }
          }catch(e){}
          }
        }
        await Promise.all(Array.from({length:CONC}, worker));
      }
    };

    const EXCHANGES = { binance: BINANCE, okx: OKX };
    const AUTO_REFRESH_MS = 5 * 60 * 1000;

    // ============ State ============
    let currentExchangeKey = 'binance';
    let currentRows = [];
    let sortKey = 'dailyPct';
    let sortDir = 'desc';
    let showTopOnly = true; // toggle button
    let isRefreshing = false;
    let refreshToken = 0;

    // ============ DOM refs ============
    const tbody = document.getElementById('tbody');
    const exchangeNameEl = document.getElementById('exchangeName');

    // ============ Rendering ============
    function renderRow(row){
      let tr = document.querySelector(`tr[data-sym="${row.symbol}"]`);
      if(!tr){ tr=document.createElement('tr'); tr.dataset.sym=row.symbol; tr.innerHTML = `
        <td class="mono"></td><td class="mono"></td><td class="mono"></td><td class="mono"></td><td class="mono"></td>
        <td class="mono"></td><td class="mono"></td><td class="mono"></td><td class="mono"></td><td class="mono"></td>`; tbody.appendChild(tr); }
      const c = tr.children;
      c[0].textContent = row.symbol;
      c[1].textContent = row.lastPrice ? nf2.format(row.lastPrice) : '—';
      c[2].innerHTML   = Number.isFinite(row.fundingRate) ? `<span class="${classForSigned(row.fundingRate)}">${toPercent(row.fundingRate)}</span>` : '<span class="skeleton"></span>';
      c[3].textContent = Number.isFinite(row.fundingIntervalHrs) ? nf0.format(row.fundingIntervalHrs) : '—';
      c[4].innerHTML   = row.dailyPct==null ? '<span class="skeleton"></span>' : `<span class="${classForSigned(row.dailyPct)}">${toPercent(row.dailyPct)}</span>`;
      c[5].innerHTML   = row.aprNow==null ? '<span class="skeleton"></span>' : `<span class="${classForSigned(row.aprNow)}">${toPercent(row.aprNow)}</span>`;
      c[6].innerHTML   = row.apr7d==null ? '<span class="skeleton"></span>' : `<span class="${classForSigned(row.apr7d)}">${toPercent(row.apr7d)}</span>`;
      c[7].innerHTML   = row.apr14d==null ? '<span class="skeleton"></span>' : `<span class="${classForSigned(row.apr14d)}">${toPercent(row.apr14d)}</span>`;
      c[8].textContent = row.quoteVolume ? nf0.format(row.quoteVolume) : '—';
      c[9].textContent = Number.isFinite(row.spotVolume) ? nf0.format(row.spotVolume) : 'n/a';
    }

    function filterRows(rows){
      const q = document.getElementById('search').value.trim().toUpperCase();
      let list = rows;
      if(q) list = list.filter(r=>r.symbol.includes(q));
      if(showTopOnly) list = list.slice(0,50);
      list = list.slice().sort((a,b)=>{
        if(sortKey==='symbol'){
          return sortDir==='asc'
            ? a.symbol.localeCompare(b.symbol)
            : b.symbol.localeCompare(a.symbol);
        }
        const av=a[sortKey], bv=b[sortKey];
        const aa=(av==null||!Number.isFinite(av))?-Infinity:av;
        const bb=(bv==null||!Number.isFinite(bv))?-Infinity:bv;
        if(aa<bb) return sortDir==='asc' ? -1 : 1;
        if(aa>bb) return sortDir==='asc' ? 1 : -1;
        return a.symbol.localeCompare(b.symbol);
      });
      return list;
    }

    function renderAll(){ tbody.innerHTML=''; filterRows(currentRows).forEach(renderRow); }

    // ============ Background enrichers ============
    async function computeAPRsCombined(id, intervalHrs){ return EXCHANGES[currentExchangeKey].computeAPRsCombined(id, intervalHrs); }
    async function inferInterval(id){ return EXCHANGES[currentExchangeKey].inferInterval(id); }

    async function fillHistoricalAPRs(rows){
      const top = filterRows(rows); // only visible
      let i=0; const CONC=6;
      async function worker(){ while(i<top.length){ const idx=i++; const rec=top[idx]; const id = rec.okxInstId || rec.symbol; try{ const both = await computeAPRsCombined(id, rec.fundingIntervalHrs); rec.apr7d=both.apr7d; rec.apr14d=both.apr14d; }catch(e){ rec.apr7d=rec.apr14d=null; } renderRow(rec);} }
      await Promise.all(Array.from({length:CONC}, worker));
    }

    async function fillFundingIntervalsFromHistory(rows){
      const list = filterRows(rows); let i=0; const CONC=6;
      async function worker(){ while(i<list.length){ const idx=i++; const rec=list[idx]; const id=rec.okxInstId||rec.symbol; try{ const inf = await inferInterval(id); if(inf && inf!==rec.fundingIntervalHrs){ rec.fundingIntervalHrs=inf; if(Number.isFinite(rec.fundingRate)){ rec.dailyPct=calcDailyPct(rec.fundingRate, inf); rec.aprNow=toAPRFromPeriodRate(rec.fundingRate, inf);} try{ const both=await computeAPRsCombined(id, inf); rec.apr7d=both.apr7d; rec.apr14d=both.apr14d; }catch(_){} renderRow(rec);} }catch(e){} } }
      await Promise.all(Array.from({length:CONC}, worker));
    }

    // ============ Events ============
    document.querySelector('.tabs').addEventListener('click', (e)=>{
      const t = e.target.closest('.tab'); if(!t) return;
      document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
      t.classList.add('active');
      switchExchange(t.dataset.exchange);
    });

    document.getElementById('refresh').addEventListener('click', ()=> switchExchange(currentExchangeKey));
    document.getElementById('toggleTop').addEventListener('click', ()=>{ showTopOnly=!showTopOnly; document.getElementById('toggleTop').textContent = showTopOnly? 'Show: Top 50 by volume' : 'Show: All'; renderAll(); });

    document.getElementById('search').addEventListener('input', debounce(()=>{ renderAll(); fillHistoricalAPRs(currentRows).catch(()=>{}); fillFundingIntervalsFromHistory(currentRows).catch(()=>{}); if(currentExchangeKey==='okx') OKX.fillFundingRatesNow(filterRows(currentRows)).catch(()=>{}); }, 200));

    document.querySelectorAll('thead th').forEach(th=> th.addEventListener('click', ()=>{ const key=th.dataset.key; if(!key) return; if(sortKey===key) sortDir = (sortDir==='asc'?'desc':'asc'); else { sortKey=key; sortDir= key==='symbol'?'asc':'desc'; } renderAll(); }));

    // ============ Exchange switching & init ============
    async function switchExchange(key){
      if(isRefreshing && key===currentExchangeKey) return;
      const token = ++refreshToken;
      isRefreshing = true;
      currentExchangeKey = key;
      exchangeNameEl.textContent = EXCHANGES[key].name;
      document.getElementById('lastUpdated').textContent = 'Refreshing…';
      tbody.innerHTML='';
      try{
        currentRows = await EXCHANGES[key].fetchAll();
        renderAll();
        document.getElementById('lastUpdated').textContent = 'Updated: ' + nowString();
        await Promise.all([
          fillHistoricalAPRs(currentRows),
          fillFundingIntervalsFromHistory(currentRows),
          key==='okx' ? OKX.fillFundingRatesNow(filterRows(currentRows)) : Promise.resolve()
        ]);
      }catch(err){
        console.error(err);
        document.getElementById('lastUpdated').textContent = 'Error loading data';
        tbody.innerHTML = `<tr><td colspan="10" style="color:var(--muted);padding:16px;">Failed to load from ${EXCHANGES[key].name} API. Try again.</td></tr>`;
      }finally{
        if(refreshToken === token) isRefreshing = false;
      }
    }

    function init(){
      switchExchange('binance');
      setInterval(()=> switchExchange(currentExchangeKey), AUTO_REFRESH_MS);
    }
    init();
  </script>
</body>
</html>
